    type: Date,
    default: Date.now
  },
  categories: [{
    name: String,           // "Black & White"
    photoCount: Number,     // 45
    processedPhotos: {      // Para controle de distribui√ß√£o
      type: Number,
      default: 0
    }
  }],
    folderMap.set(folder.id, {
      id: folder.id,
      name: folder.name,
      parents: folder.parents || [],
      children: [],
      fileCount: 0, // Ser√° preenchido posteriormente
      isAll: false,
      isLeaf: true
    });
  });
  
--
    rootFolders.unshift({
      id: 'all-items',
      name: 'All Items',
      parents: [],
      children: [],
      fileCount: 0,
      isAll: true,
      isLeaf: false
    });
  }
  
        console.log(`üìÅ Criando pasta de destino: ${targetFolderName}`);
        targetFolder = {
          id: localStorageService.generateId(),
          name: targetFolderName,
          relativePath: targetFolderName,
          photoCount: 0,
          children: []
        };
        index.folders.push(targetFolder);
      }

--

      const folders = statusFolder.children.map(folder => ({
        id: folder.id,
        name: folder.name,
        createdTime: folder.createdTime || new Date().toISOString(),
        photoCount: folder.photoCount || 0
      }));

      console.log(`üìã Encontrados ${folders.length} pedidos em ${folderName}`);

      return { success: true, folders };
--
    }
    return result;
  }

  // Atualizar √≠ndice com informa√ß√µes do pedido
  async updateIndexForOrder(statusFolder, folderName, folderId, photoCount) {
    console.log(`üìù Atualizando √≠ndice para pasta: ${statusFolder}/${folderName}`);

    try {
      const index = await localStorageService.getIndex();

--
        // Criar a pasta se n√£o existir
        parentFolder = {
          id: localStorageService.generateId(),
          name: statusFolder,
          relativePath: statusFolder,
          photoCount: 0,
          children: []
        };
        index.folders.push(parentFolder);
      }

--
      // Adicionar o pedido
      parentFolder.children.push({
        id: folderId,
        name: folderName,
        relativePath: path.join(statusFolder, folderName),
        photoCount: photoCount,
        createdTime: new Date().toISOString()
      });

      console.log(`‚úÖ Pedido adicionado ao √≠ndice: ${folderName}`);

--
        order: {
          id: folderId,
          name: orderFolder.name,
          status: parentFolderName,
          createdTime: orderFolder.createdTime,
          photoCount: orderFolder.photoCount,
          categories: categories,
          path: orderPath
        }
      };
    } catch (error) {
--
        if (parentFolder && parentFolder.children) {
          parentFolder.children = parentFolder.children.filter(f => f.id !== folderId);
        }
      } else {
        // Atualizar contador de fotos no √≠ndice
        orderFolder.photoCount = (orderFolder.photoCount || 0) - movedPhotos;
      }

      // Salvar √≠ndice atualizado
      await localStorageService.saveIndex(index);
      //await localStorageService.rebuildIndex(); // Rebuild para atualizar contadores
--
      const index = await localStorageService.getIndex();
      let updated = false;

      // Para cada categoria que teve fotos movidas
      for (const [categoryName, photos] of Object.entries(photosByCategory)) {
        const photoCount = photos.length;
        console.log(`üìâ Categoria "${categoryName}": diminuindo ${photoCount} fotos`);

        // Encontrar categoria no √≠ndice
        const category = this.findCategoryByNameInIndex(index, categoryName);
        if (category) {
          category.photoCount = Math.max(0, (category.photoCount || 0) - photoCount);
          console.log(`‚úÖ "${categoryName}": novo contador = ${category.photoCount}`);
          updated = true;
        } else {
          console.warn(`‚ö†Ô∏è Categoria "${categoryName}" n√£o encontrada no √≠ndice`);
        }
      }
      const folders = await this.getFolderStructure(true, true);
      
      // Filtrar pastas vazias se necess√°rio
      let filteredFolders = folders;
      if (!includeEmpty) {
        filteredFolders = folders.filter(folder => folder.fileCount && folder.fileCount > 0);
      }
      
      console.log(`[LocalStorage] Returning ${filteredFolders.length} folders for admin`);
      
      return {
--
    const adminFolders = ['Waiting Payment', 'Sold', 'Developing'];
    let folders = [];

    // FUN√á√ÉO RECURSIVA CORRIGIDA
    const processFolder = (folderData, parentPath = []) => {
      console.log(`[DEBUG] Processing folder: ${folderData.name}, photoCount: ${folderData.photoCount}, isAdmin: ${isAdmin}`);
      
      const currentPath = [...parentPath, folderData.name];
      
      if (!isAdmin && adminFolders.includes(folderData.name)) {
        console.log(`[DEBUG] Skipping admin folder: ${folderData.name}`);
--
      }

      // CORRE√á√ÉO: Para clientes, mostrar APENAS pastas com fotos (subpastas finais)
      if (!isAdmin) {
        // Se esta pasta tem fotos diretamente, adicionar
        if (folderData.photoCount && folderData.photoCount > 0) {
          console.log(`[DEBUG] Adding folder with photos: ${folderData.name} (${folderData.photoCount} photos)`);
          folders.push({
            id: folderData.id,
            name: folderData.name,
            path: currentPath,
            fullPath: currentPath.join(' ‚Üí '),
            isAll: false,
            isLeaf: true,
            fileCount: folderData.photoCount
          });
        }
        
        // Processar filhos para encontrar mais pastas com fotos
        if (folderData.children && folderData.children.length > 0) {
--
          id: folderData.id,
          name: folderData.name,
          path: currentPath,
          fullPath: currentPath.join(' ‚Üí '),
          isAll: false,
          isLeaf: folderData.photoCount > 0,
          fileCount: folderData.photoCount || 0,
          hasChildren: folderData.children && folderData.children.length > 0
        });
        
        if (folderData.children && folderData.children.length > 0) {
          folderData.children.forEach(child => {
--
      folders.unshift({
        id: 'all-items',
        name: 'All Items',
        isAll: true,
        isLeaf: false,
        fileCount: index.totalPhotos || 0
      });
    }

    console.log(`[DEBUG] Final folders count: ${folders.length}`);
    console.log(`[DEBUG] First few folders:`, folders.slice(0, 3));
--
  async getAllPhotos() {
    const photos = [];
    const index = await this.getIndex();

    const processFolder = async (folder) => {
      if (folder.photoCount > 0) {
        const categoryPhotos = await this.getPhotos(folder.id);
        photos.push(...categoryPhotos);
      }

      if (folder.children) {
--
      const items = await fs.readdir(folderPath, { withFileTypes: true });
      const folder = {
        id: this.generateId(),
        name: path.basename(folderPath),
        relativePath: relativePath,
        photoCount: 0,
        children: []
      };
      
      for (const item of items) {
        const itemPath = path.join(folderPath, item.name);
--
        
        if (item.isDirectory()) {
          const childFolder = await scanFolder(itemPath, itemRelativePath);
          folder.children.push(childFolder);
        } else if (this.isImageFile(item.name)) {
          folder.photoCount++;
          index.totalPhotos++;
        }
      }
      
      return folder;
--
  }

  async getStorageStats() {
    return {
      totalSize: 0,
      photoCount: 0,
      folderCount: 0,
      usedGB: '0',
      availableGB: '50',
      percentUsed: '0'
    };
--
      // Mostrar estrutura das primeiras 3 pastas
      if (index.folders && index.folders.length > 0) {
        index.folders.slice(0, 3).forEach((folder, i) => {
          console.log(`[DEBUG] Folder ${i + 1}:`, {
            name: folder.name,
            photoCount: folder.photoCount,
            hasChildren: folder.children ? folder.children.length : 0
          });
          
          // Mostrar primeiros filhos tamb√©m
          if (folder.children && folder.children.length > 0) {
            folder.children.slice(0, 2).forEach((child, j) => {
              console.log(`  Child ${j + 1}:`, {
                name: child.name,
                photoCount: child.photoCount,
                hasChildren: child.children ? child.children.length : 0
              });
            });
          }
        });
--
      const index = await this.getIndex();
      
      // Encontrar e atualizar pasta origem
      const sourceInIndex = this.findCategoryById(index, sourceFolder.id);
      if (sourceInIndex) {
        sourceInIndex.photoCount = Math.max(0, (sourceInIndex.photoCount || 0) - movedCount);
        console.log(`üìâ Source folder ${sourceFolder.name}: ${sourceInIndex.photoCount} photos remaining`);
      }
      
      // Encontrar e atualizar pasta destino
      const destinationInIndex = this.findCategoryById(index, destinationFolder.id);
      if (destinationInIndex) {
        destinationInIndex.photoCount = (destinationInIndex.photoCount || 0) + movedCount;
        console.log(`üìà Destination folder ${destinationFolder.name}: ${destinationInIndex.photoCount} photos total`);
      }
      
      // Atualizar timestamp do √≠ndice
      index.lastUpdate = new Date().toISOString();
      
--
      const index = await this.getIndex();
      
      // Encontrar e atualizar pasta no √≠ndice
      const folderInIndex = this.findCategoryById(index, sourceFolder.id);
      if (folderInIndex) {
        folderInIndex.photoCount = Math.max(0, (folderInIndex.photoCount || 0) - deletedCount);
        console.log(`üìâ Folder ${sourceFolder.name}: ${folderInIndex.photoCount} photos remaining`);
      }
      
      // Atualizar total geral
      index.totalPhotos = Math.max(0, (index.totalPhotos || 0) - deletedCount);
      
      console.log(`   Total processado: ${totalProcessed}`);

      // Atualizar shipment no banco
      const categories = Object.entries(categoriesData).map(([name, files]) => ({
        name,
        photoCount: files.length,
        processedPhotos: 0
      }));

      shipment.categories = categories;
      shipment.totalPhotos = totalProcessed;
      await shipment.save();

      console.log(`‚úÖ Upload completed: ${totalProcessed} photos in ${categories.length} categories`);
      console.log('üìÅ Categories found:', categories.map(c => `${c.name} (${c.photoCount} photos)`));

      res.status(200).json({
        success: true,
        processedPhotos: totalProcessed,
        categories: categories,
--
            const photoFiles = files.filter(f => f.endsWith('.webp'));

            if (photoFiles.length > 0) {
              categories.push({
                name: item.name,
                photoCount: photoFiles.length,
                photos: photoFiles.map(f => ({
                  name: f,
                  id: path.parse(f).name
                }))
              });
  // Fun√ß√£o recursiva para procurar a foto FISICAMENTE
  const searchInFolder = async (folder, parentPath = []) => {
    const currentPath = [...parentPath, folder.name];

    // Se esta pasta tem fotos, verificar FISICAMENTE se nossa foto est√° aqui
    if (folder.photoCount > 0 && folder.relativePath) {
      try {
        const folderPath = path.join('/opt/render/project/storage/cache/fotos/imagens-webp', folder.relativePath);
        const photoPath = path.join(folderPath, `${photoId}.webp`);
        
        // ‚úÖ VERIFICAR SE ARQUIVO EXISTE FISICAMENTE
--
      folderName: order.name,
      status: order.status,
      created: order.createdTime,
      categories: categories,
      comments: mongoOrder ? mongoOrder.comments : '',
      photoCount: order.photoCount
    });

  } catch (error) {
    console.error('Error getting order details:', error);
    res.status(500).json({
    
    // Converter para o formato esperado pelo frontend
    const formattedFolders = folders.map(folder => ({
      id: folder.id,
      name: folder.name,
      fileCount: folder.fileCount || 0,
      path: folder.fullPath || folder.path || folder.name
    }));
    
    res.status(200).json({
      success: true,
      if (adminFolderNames.includes(category.name)) return false;
      
      // Para clientes regulares, verificar adicionalmente:
      if (!isAdmin) {
        // MODIFICA√á√ÉO: Verifica√ß√£o mais robusta - excluir categorias sem fotos
        if (!category.fileCount || category.fileCount <= 0) {
          console.log(`Excluindo categoria ${category.name} por n√£o conter fotos (count=${category.fileCount})`);
          return false;
        }
      }
      
      return true; // Manter outras categorias
--
    const accessFilteredCategories = filteredCategories.filter(category => {
      // Categoria "All Items" sempre habilitada
      if (category.isAll) return true;
      
      // MODIFICA√á√ÉO: Verifica√ß√£o redundante para garantir que a categoria tem arquivos
      if (!category.fileCount || category.fileCount === 0) return false;
      
      // CORRE√á√ÉO: Se n√£o tiver configura√ß√£o espec√≠fica, PERMITIR por padr√£o
      if (accessMap[category.id] === undefined) return true;
      
      // Usar configura√ß√£o de acesso
--
        }
      } else {
        console.log(`Sem configura√ß√£o de acesso para ${folder.name}, permitindo por padr√£o`);
      }
      
      // MODIFICADO: Verifica√ß√£o mais robusta para fileCount
      if (!folder.fileCount || folder.fileCount <= 0) {
        console.log(`Excluindo categoria ${folder.name} por estar vazia (fileCount=${folder.fileCount})`);
        return false;
      }
      
      // CORRE√á√ÉO: Por padr√£o, permitir acesso (incluir a categoria)
      return true;
--
      name: cat.name,
      path: cat.path || [],
      fullPath: cat.fullPath || cat.name,
      isAll: false,
      isLeaf: true,
      fileCount: cat.fileCount
    }));
    
    console.log(`Total de ${categories.length} categorias sendo retornadas ao cliente`);
    
    // Retornar todos os dados combinados
