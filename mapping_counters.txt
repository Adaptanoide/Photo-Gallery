        if (parentFolder && parentFolder.children) {
          parentFolder.children = parentFolder.children.filter(f => f.id !== folderId);
        }
      } else {
        // Atualizar contador de fotos no √≠ndice
        orderFolder.photoCount = (orderFolder.photoCount || 0) - movedPhotos;
      }

      // Salvar √≠ndice atualizado
      await localStorageService.saveIndex(index);
      //await localStorageService.rebuildIndex(); // Rebuild para atualizar contadores
      localStorageService.clearCache();

      console.log(`‚úÖ ${movedPhotos} fotos retornadas ao estoque`);

      return {
--
      const index = await localStorageService.getIndex();
      let updated = false;

      // Para cada categoria que teve fotos movidas
      for (const [categoryName, photos] of Object.entries(photosByCategory)) {
        const photoCount = photos.length;
        console.log(`üìâ Categoria "${categoryName}": diminuindo ${photoCount} fotos`);

        // Encontrar categoria no √≠ndice
        const category = this.findCategoryByNameInIndex(index, categoryName);
        if (category) {
          category.photoCount = Math.max(0, (category.photoCount || 0) - photoCount);
          console.log(`‚úÖ "${categoryName}": novo contador = ${category.photoCount}`);
          updated = true;
        } else {
          console.warn(`‚ö†Ô∏è Categoria "${categoryName}" n√£o encontrada no √≠ndice`);
        }
      }

      if (updated) {
        // Salvar √≠ndice atualizado
        await localStorageService.saveIndex(index);
      const index = await this.getIndex();
      
      // Encontrar e atualizar pasta origem
      const sourceInIndex = this.findCategoryById(index, sourceFolder.id);
      if (sourceInIndex) {
        sourceInIndex.photoCount = Math.max(0, (sourceInIndex.photoCount || 0) - movedCount);
        console.log(`üìâ Source folder ${sourceFolder.name}: ${sourceInIndex.photoCount} photos remaining`);
      }
      
      // Encontrar e atualizar pasta destino
      const destinationInIndex = this.findCategoryById(index, destinationFolder.id);
      if (destinationInIndex) {
        destinationInIndex.photoCount = (destinationInIndex.photoCount || 0) + movedCount;
        console.log(`üìà Destination folder ${destinationFolder.name}: ${destinationInIndex.photoCount} photos total`);
      }
      
      // Atualizar timestamp do √≠ndice
      index.lastUpdate = new Date().toISOString();
      
      // Salvar √≠ndice atualizado
      await this.saveIndex(index);
      
      // Limpar cache para for√ßar recarregamento
--
      const index = await this.getIndex();
      
      // Encontrar e atualizar pasta no √≠ndice
      const folderInIndex = this.findCategoryById(index, sourceFolder.id);
      if (folderInIndex) {
        folderInIndex.photoCount = Math.max(0, (folderInIndex.photoCount || 0) - deletedCount);
        console.log(`üìâ Folder ${sourceFolder.name}: ${folderInIndex.photoCount} photos remaining`);
      }
      
      // Atualizar total geral
      index.totalPhotos = Math.max(0, (index.totalPhotos || 0) - deletedCount);
      
      // Atualizar timestamp
      index.lastUpdate = new Date().toISOString();
      
      // Salvar √≠ndice atualizado
      if (adminFolderNames.includes(category.name)) return false;
      
      // Para clientes regulares, verificar adicionalmente:
      if (!isAdmin) {
        // MODIFICA√á√ÉO: Verifica√ß√£o mais robusta - excluir categorias sem fotos
        if (!category.fileCount || category.fileCount <= 0) {
          console.log(`Excluindo categoria ${category.name} por n√£o conter fotos (count=${category.fileCount})`);
          return false;
        }
      }
      
      return true; // Manter outras categorias
    });
    
    // Se n√£o for um cliente, retornar categorias filtradas
    if (!customerCode) {
--
    const accessFilteredCategories = filteredCategories.filter(category => {
      // Categoria "All Items" sempre habilitada
      if (category.isAll) return true;
      
      // MODIFICA√á√ÉO: Verifica√ß√£o redundante para garantir que a categoria tem arquivos
      if (!category.fileCount || category.fileCount === 0) return false;
      
      // CORRE√á√ÉO: Se n√£o tiver configura√ß√£o espec√≠fica, PERMITIR por padr√£o
      if (accessMap[category.id] === undefined) return true;
      
      // Usar configura√ß√£o de acesso
      return accessMap[category.id];
    });
    
    console.log(`getCategories - Filtrando de ${filteredCategories.length} para ${accessFilteredCategories.length} categorias acess√≠veis`);
    
--
      } else {
        console.log(`Sem configura√ß√£o de acesso para ${folder.name}, permitindo por padr√£o`);
      }
      
      // MODIFICADO: Verifica√ß√£o mais robusta para fileCount
      if (!folder.fileCount || folder.fileCount <= 0) {
        console.log(`Excluindo categoria ${folder.name} por estar vazia (fileCount=${folder.fileCount})`);
        return false;
      }
      
      // CORRE√á√ÉO: Por padr√£o, permitir acesso (incluir a categoria)
      return true;
    });
    
    console.log(`Categorias permitidas ap√≥s filtragem: ${allowedCategories.length}`);
    allowedCategories.forEach(cat => console.log(`- ${cat.name}`));
    
